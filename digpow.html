<!DOCTYPE html>
<html>
    <head></head>
    <body>

        Hello
        
        Some numbers have funny properties. For example:

        89 --> 8¹ + 9² = 89 * 1

        695 --> 6² + 9³ + 5⁴= 1390 = 695 * 2

        46288 --> 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51

        Given a positive integer n written as abcd... (a, b, c, d... being digits) and a positive integer p

        we want to find a positive integer k, if it exists, such that the sum of the digits of n taken to the successive powers of p is equal to k * n.
        In other words:

        Is there an integer k such as : (a ^ p + b ^ (p+1) + c ^(p+2) + d ^ (p+3) + ...) = n * k

        If it is the case we will return k, if not return -1.

        Note: n and p will always be given as strictly positive integers.

        digPow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1
        digPow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k
        digPow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2
        digPow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51

        <script>
            // function digPow(n, p){
            //     let string = n.toString();
            //     let len = string.length;
            //     let result = 0;
            //     for(var i = 0; i < len ; i++) {
            //         var numberser = parseInt(string.charAt(i));
            //         result +=  Math.pow(numberser, p + i)
            //     }
            //     var x = Math.pow(n,p);
            //     if(result === x){
            //         return p;
            //         } else if(result%n === 0) {
            //         return result / n;
            //     }else {
            //         return -1  
            //     }
            // }

            // practise 1
            function digPow(n, p){
                let string = n.toString();
                let length = string.length;
                var powresult = 0;
                for(let i = 0; i < length; i++){
                    let numberParse = parseInt(string.charAt(i));
                    powresult += Math.pow(numberParse, p + i);
                }
                console.log(powresult);
                var result = Math.pow(n,p);
                return (powresult === result) ? p : (powresult%n === 0) ? (powresult / n) : -1 
            }

            // Example 1
            // function digPow(n, p){
            //     var str = String(n)
            //     var res = 0;
                
            //     for(var i=0; i<str.length; i++){
            //         res += Math.pow(parseInt(str[i]),p++); 
            //     }
                
            //     return res%n === 0 ? res/n : -1;
            // }

            // Example 2
            // function digPow(n, p){
            //     const result = `${n}`.split('').reduce((sum, i) => sum += i ** p++, 0)
            //     return result % n ? -1 : result / n
            // }


            digPow(89, 1)
            digPow(92, 1)
            digPow(46288, 3)
        </script>
    </body>
</html>